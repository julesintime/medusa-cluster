apiVersion: v1
kind: ConfigMap
metadata:
  name: litellm-key-pool-config
  namespace: litellm
data:
  key-pool-config.json: |
    {
      "meta": {
        "description": "LiteLLM Enterprise Key Pool Configuration",
        "version": "1.0",
        "total_keys": 2,
        "scaling_target": 100
      },
      "providers": {
        "gemini": {
          "base_model": "gemini",
          "keys": [
            {
              "api_key": "GEMINI_KEY_1_PLACEHOLDER",
              "key_id": "gemini-key-1", 
              "rpm_limit": 15,
              "tpm_limit": 1000000,
              "daily_quota": 1500,
              "priority_models": [
                {
                  "model": "gemini-2.0-flash",
                  "rpm": 15,
                  "tpm": 1000000,
                  "weight": 10,
                  "priority": 1,
                  "cooldown_time": 60
                },
                {
                  "model": "gemini-2.0-flash-exp", 
                  "rpm": 12,
                  "tpm": 800000,
                  "weight": 8,
                  "priority": 2,
                  "cooldown_time": 60
                },
                {
                  "model": "gemini-1.5-pro-latest",
                  "rpm": 10,
                  "tpm": 600000,
                  "weight": 5,
                  "priority": 3,
                  "cooldown_time": 90
                }
              ]
            },
            {
              "api_key": "GEMINI_KEY_2_PLACEHOLDER",
              "key_id": "gemini-key-2",
              "rpm_limit": 15, 
              "tpm_limit": 1000000,
              "daily_quota": 1500,
              "priority_models": [
                {
                  "model": "gemini-2.0-flash",
                  "rpm": 15,
                  "tpm": 1000000,
                  "weight": 10,
                  "priority": 1,
                  "cooldown_time": 60
                },
                {
                  "model": "gemini-2.0-flash-exp",
                  "rpm": 12, 
                  "tpm": 800000,
                  "weight": 8,
                  "priority": 2,
                  "cooldown_time": 60
                }
              ]
            }
          ]
        }
      },
      "routing_strategy": {
        "strategy": "simple-shuffle",
        "wildcard_models": [
          "*",
          "gpt-4",
          "gpt-4o", 
          "gpt-3.5-turbo",
          "claude-3-opus",
          "claude-3-sonnet"
        ],
        "default_fallback_chain": [
          "gemini-2.0-flash",
          "gemini-2.0-flash-exp", 
          "gemini-1.5-pro-latest"
        ],
        "load_balancing": {
          "method": "weighted_round_robin",
          "health_check_interval": 30,
          "retry_attempts": 3,
          "backoff_multiplier": 2
        }
      },
      "rate_limit_handling": {
        "detection_keywords": [
          "rate limit",
          "quota exceeded", 
          "too many requests",
          "resource exhausted"
        ],
        "fallback_delay": 5,
        "circuit_breaker": {
          "failure_threshold": 3,
          "recovery_timeout": 300
        }
      }
    }
  
  litellm-bootstrap.py: |
    #!/usr/bin/env python3
    """
    LiteLLM Enterprise Key Pool Bootstrap Script
    Configures LiteLLM with dynamic key pools and intelligent routing
    """

    import json
    import requests
    import time
    import os
    import sys
    import logging
    from typing import Dict, List, Any
    from dataclasses import dataclass

    # Configure logging
    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
    logger = logging.getLogger(__name__)

    @dataclass
    class LiteLLMConfig:
        base_url: str
        master_key: str
        timeout: int = 30
        max_retries: int = 5

    class LiteLLMKeyPoolManager:
        def __init__(self, config: LiteLLMConfig):
            self.config = config
            self.session = requests.Session()
            self.session.headers.update({
                'Authorization': f'Bearer {config.master_key}',
                'Content-Type': 'application/json'
            })
        
        def wait_for_litellm_ready(self) -> bool:
            """Wait for LiteLLM to be ready before configuration"""
            logger.info("Waiting for LiteLLM to be ready...")
            for attempt in range(self.config.max_retries):
                try:
                    response = self.session.get(f"{self.config.base_url}/health", timeout=self.config.timeout)
                    if response.status_code == 200:
                        logger.info("LiteLLM is ready!")
                        return True
                except requests.RequestException as e:
                    logger.warning(f"LiteLLM not ready (attempt {attempt + 1}/{self.config.max_retries}): {e}")
                    time.sleep(10)
            
            logger.error("LiteLLM failed to become ready")
            return False
        
        def clear_existing_models(self) -> bool:
            """Clear existing models to start fresh"""
            try:
                logger.info("Clearing existing models...")
                response = self.session.get(f"{self.config.base_url}/model/info")
                
                if response.status_code == 200:
                    existing_models = response.json().get('data', [])
                    for model in existing_models:
                        model_id = model.get('id')
                        if model_id and not model_id.startswith('*'):  # Don't delete wildcard models
                            delete_response = self.session.delete(f"{self.config.base_url}/model/{model_id}")
                            if delete_response.status_code == 200:
                                logger.info(f"Deleted existing model: {model_id}")
                            else:
                                logger.warning(f"Failed to delete model {model_id}: {delete_response.text}")
                
                return True
            except Exception as e:
                logger.warning(f"Error clearing existing models: {e}")
                return True  # Continue even if clearing fails
        
        def add_model_with_key_rotation(self, model_name: str, all_keys: List[Dict[str, Any]]) -> bool:
            """Add a single model deployment with multiple keys for rotation"""
            
            # Create model deployments for each key - LiteLLM will rotate between them
            deployment_names = []
            for key_config in all_keys:
                deployment_name = f"{model_name}-{key_config['key_id']}"
                
                payload = {
                    "model_name": deployment_name,
                    "litellm_params": {
                        "model": f"gemini/{model_name}",
                        "api_key": key_config['api_key'],
                        "rpm": key_config.get('rpm_limit', 15),
                        "tpm": key_config.get('tpm_limit', 1000000)
                    },
                    "model_info": {
                        "id": deployment_name,
                        "key_id": key_config['key_id']
                    }
                }
                
                try:
                    response = self.session.post(f"{self.config.base_url}/model/new", json=payload, timeout=self.config.timeout)
                    
                    if response.status_code == 200:
                        logger.info(f"‚úÖ Added key deployment for {model_name}: {deployment_name}")
                        deployment_names.append(deployment_name)
                    else:
                        logger.error(f"‚ùå Failed to add key deployment {deployment_name}: {response.text}")
                        return False
                        
                except requests.RequestException as e:
                    logger.error(f"‚ùå Request failed for deployment {deployment_name}: {e}")
                    return False
            
            return len(deployment_names) > 0
        
        def create_virtual_key(self, models: List[str], alias: str = "enterprise-key-pool") -> str:
            """Create a single virtual key for accessing all models"""
            payload = {
                "models": models,
                "key_alias": alias,
                "duration": None,  # No expiration
                "metadata": {
                    "type": "enterprise_key_pool",
                    "description": "Single key for load-balanced access to all provider keys",
                    "auto_generated": True
                }
            }
            
            try:
                response = self.session.post(f"{self.config.base_url}/key/generate", json=payload, timeout=self.config.timeout)
                
                if response.status_code == 200:
                    data = response.json()
                    virtual_key = data.get('key')
                    logger.info(f"üîë Created virtual key: {virtual_key}")
                    return virtual_key
                else:
                    logger.error(f"‚ùå Failed to create virtual key: {response.text}")
                    return ""
                    
            except requests.RequestException as e:
                logger.error(f"‚ùå Request failed for virtual key creation: {e}")
                return ""
        
        def setup_key_pool(self, key_pool_config: Dict[str, Any]) -> Dict[str, Any]:
            """Setup the complete key pool configuration"""
            logger.info("üöÄ Starting LiteLLM Key Pool Setup...")
            
            # Wait for LiteLLM to be ready
            if not self.wait_for_litellm_ready():
                return {"success": False, "error": "LiteLLM not ready"}
            
            # Clear existing models
            self.clear_existing_models()
            
            results = {
                "success": True,
                "models_added": [],
                "models_failed": [],
                "virtual_key": "",
                "total_deployments": 0
            }
            
            # Process each provider to collect all keys
            all_keys = []
            for provider_name, provider_config in key_pool_config.get('providers', {}).items():
                logger.info(f"üì¶ Processing provider: {provider_name}")
                
                for key_config in provider_config.get('keys', []):
                    all_keys.append(key_config)
                    logger.info(f"üîê Added key: {key_config['key_id']}")
            
            # Create ONE model with key rotation
            model_name = "gemini-2.0-flash"  # Single primary model
            logger.info(f"üéØ Setting up single model with key rotation: {model_name}")
            
            if all_keys:
                success = self.add_model_with_key_rotation(model_name, all_keys)
                
                if success:
                    results["models_added"].append(model_name)
                    results["total_deployments"] = len(all_keys)
                    logger.info(f"‚úÖ Created {model_name} with {len(all_keys)} key rotations")
                else:
                    results["models_failed"].append(model_name)
                    logger.error(f"‚ùå Failed to create {model_name} with key rotation")
            
            # Create single virtual key with wildcard access for model aliasing
            virtual_key = self.create_virtual_key(["*"])
            results["virtual_key"] = virtual_key
            
            # Log summary
            logger.info(f"üìä Setup Summary:")
            logger.info(f"   üéØ Single Model: {model_name}")
            logger.info(f"   üîë Keys Available: {len(all_keys)}")
            logger.info(f"   üîÑ Key Rotation: Enabled")
            logger.info(f"   üöÄ Virtual Key: {results['virtual_key']}")
            logger.info(f"   üìà Total Deployments: {results['total_deployments']}")
            
            return results

    def load_key_pool_config(config_path: str) -> Dict[str, Any]:
        """Load key pool configuration from JSON file"""
        try:
            with open(config_path, 'r') as f:
                config = json.load(f)
            
            # Replace placeholder API keys with actual values from environment
            for provider_name, provider_config in config.get('providers', {}).items():
                for i, key_config in enumerate(provider_config.get('keys', [])):
                    api_key = key_config['api_key']
                    if api_key.endswith('_PLACEHOLDER'):
                        env_var = api_key.replace('_PLACEHOLDER', '')
                        actual_key = os.getenv(env_var)
                        if actual_key:
                            config['providers'][provider_name]['keys'][i]['api_key'] = actual_key
                            logger.info(f"üîß Loaded {env_var} from environment")
                        else:
                            logger.warning(f"‚ö†Ô∏è Environment variable {env_var} not found")
            
            return config
        except Exception as e:
            logger.error(f"‚ùå Failed to load config from {config_path}: {e}")
            return {}

    def save_virtual_key(virtual_key: str, output_path: str = "/tmp/litellm-virtual-key.txt"):
        """Save the virtual key for external access"""
        try:
            with open(output_path, 'w') as f:
                f.write(virtual_key)
            logger.info(f"üíæ Virtual key saved to: {output_path}")
        except Exception as e:
            logger.error(f"‚ùå Failed to save virtual key: {e}")

    def main():
        """Main execution function"""
        logger.info("üåü LiteLLM Enterprise Key Pool Bootstrap Starting...")
        
        # Configuration
        litellm_config = LiteLLMConfig(
            base_url=os.getenv('LITELLM_BASE_URL', 'http://localhost:4000'),
            master_key=os.getenv('LITELLM_MASTER_KEY', 'lo2v6ewnDLY2JXapRNTqdYZGs6Up2kHmzGfGbw5STr8='),
            timeout=30,
            max_retries=10
        )
        
        config_path = os.getenv('KEY_POOL_CONFIG_PATH', '/config/key-pool-config.json')
        
        # Load configuration
        key_pool_config = load_key_pool_config(config_path)
        if not key_pool_config:
            logger.error("‚ùå Failed to load key pool configuration")
            sys.exit(1)
        
        # Initialize manager and setup key pool
        manager = LiteLLMKeyPoolManager(litellm_config)
        results = manager.setup_key_pool(key_pool_config)
        
        if results["success"]:
            logger.info("üéâ Key pool setup completed successfully!")
            
            # Save virtual key for external access
            if results["virtual_key"]:
                save_virtual_key(results["virtual_key"])
                
            # Print final summary
            print("\n" + "="*60)
            print("üöÄ LITELLM ENTERPRISE KEY POOL READY")
            print("="*60)
            print(f"üîë Virtual Key: {results['virtual_key']}")
            print(f"üìä Total Models: {len(results['models_added'])}")
            print(f"üåê API Endpoint: {litellm_config.base_url}")
            print("="*60)
            print("\nüí° Usage:")
            print(f"   curl -X POST '{litellm_config.base_url}/v1/chat/completions' \\")
            print(f"     -H 'Authorization: Bearer {results['virtual_key']}' \\")
            print(f"     -H 'Content-Type: application/json' \\")
            print(f"     -d '{{\"model\": \"gpt-4\", \"messages\": [{{\"role\": \"user\", \"content\": \"Hello!\"}}]}}'")
            print("\n")
            
        else:
            logger.error("‚ùå Key pool setup failed")
            sys.exit(1)

    if __name__ == "__main__":
        main()