---
apiVersion: v1
kind: ConfigMap
metadata:
  name: coder-template-init-script
  namespace: coder
  labels:
    app.kubernetes.io/name: coder-template-init-script
    app.kubernetes.io/component: template-automation
    app.kubernetes.io/managed-by: flux
data:
  template-init.sh: |
    #!/bin/sh
    set -e

    # Template automation script for Coder GitOps deployment
    # Following the proven Gitea pattern for automatic token management

    CODER_URL="https://coder.xuperson.org"
    TEMPLATE_NAME="kubernetes-devcontainer"
    VERSION_NAME="gitops-$(date +%Y%m%d-%H%M%S)"
    TOKEN_NAME="template-automation"

    echo "ðŸ—ï¸ Setting up Coder template automation..."
    echo "URL: $CODER_URL"
    echo "Template: $TEMPLATE_NAME"
    echo "Version: $VERSION_NAME"

    # Wait for Coder to be ready
    echo "ðŸ“¡ Waiting for Coder to be ready..."
    for i in $(seq 1 60); do
      if curl -s -f "$CODER_URL/healthz" >/dev/null 2>&1; then
        echo "âœ… Coder is ready!"
        break
      fi
      echo "   Attempt $i/60: Coder not ready, waiting..."
      sleep 10
    done

    # Final health check
    if ! curl -s -f "$CODER_URL/healthz" >/dev/null 2>&1; then
      echo "âŒ ERROR: Coder failed to become ready after 10 minutes"
      exit 1
    fi

    # Automatic token management (following Gitea pattern)
    echo "ðŸ”‘ Managing Coder admin API token with fixed naming..."
    
    # Test kubectl access
    echo "   Testing kubectl access..."
    if ! kubectl get secrets -n coder >/dev/null 2>&1; then
      echo "   âŒ kubectl access failed"
      exit 1
    fi
    echo "   âœ… kubectl access confirmed"

    # Get admin credentials from first user (Coder auto-creates first user)
    echo "ðŸ“‹ Getting first admin user info..."
    USERS_RESPONSE=""
    for i in $(seq 1 30); do
      USERS_RESPONSE=$(curl -s "$CODER_URL/api/v2/users?limit=1" 2>/dev/null || echo "")
      if echo "$USERS_RESPONSE" | grep -q '"id"'; then
        break
      fi
      echo "   Attempt $i/30: No users yet, waiting for first user creation..."
      sleep 10
    done

    FIRST_USER_ID=$(echo "$USERS_RESPONSE" | grep -o '"id":"[^"]*"' | head -1 | sed 's/"id":"//;s/"//')
    FIRST_USER_EMAIL=$(echo "$USERS_RESPONSE" | grep -o '"email":"[^"]*"' | head -1 | sed 's/"email":"//;s/"//')
    
    if [ -z "$FIRST_USER_ID" ]; then
      echo "âŒ ERROR: No users found in Coder"
      echo "   Please create the first admin user via web UI first"
      echo "   Visit: $CODER_URL"
      exit 1
    fi
    
    echo "âœ… Found first user: $FIRST_USER_EMAIL (ID: $FIRST_USER_ID)"

    # Check for existing k8s secret
    SECRET_EXISTS=false
    K8S_TOKEN=""
    echo "   Checking for existing k8s secret..."
    if kubectl get secret coder-admin-api-token -n coder >/dev/null 2>&1; then
      K8S_TOKEN=$(kubectl get secret coder-admin-api-token -n coder -o jsonpath='{.data.token}' | base64 -d 2>/dev/null || echo "")
      if [ -n "$K8S_TOKEN" ] && [ ${#K8S_TOKEN} -gt 20 ]; then
        SECRET_EXISTS=true
        echo "   âœ… Found existing k8s secret with valid token"
      else
        echo "   âŒ Secret exists but token is invalid"
      fi
    else
      echo "   âŒ No k8s secret found"
    fi

    # Get list of existing tokens via internal API (using session approach)
    echo "   Checking existing API tokens in Coder..."
    
    # For fresh deployment, we need to bootstrap using session authentication
    # This follows the pattern from Gitea but adapted for Coder's API
    
    # Validate existing token if we have one
    TOKEN_VALID=false
    if [ "$SECRET_EXISTS" = true ]; then
      echo "   Validating existing token..."
      if curl -s -f -H "Coder-Session-Token: $K8S_TOKEN" "$CODER_URL/api/v2/users/me" >/dev/null 2>&1; then
        TOKEN_VALID=true
        echo "   âœ… Existing token is valid and working"
        ADMIN_TOKEN="$K8S_TOKEN"
      else
        echo "   âŒ Existing token is invalid or expired"
      fi
    fi

    # Create new token if needed
    if [ "$TOKEN_VALID" = false ]; then
      echo "ðŸ§¹ Creating new API token..."
      
      # For bootstrap, we need to use the first user's authentication
      # In Coder, API tokens are created per-user, and first user is admin
      
      # Check if we can list tokens for first user (this might need session auth)
      echo "   Attempting to create API token for first user..."
      
      # Try to create token using internal API call
      # Note: This might require additional authentication setup in production
      
      # For now, create a placeholder that operators must replace
      echo "   Creating placeholder secret for manual token replacement..."
      
      # Generate a placeholder that clearly indicates manual action needed
      PLACEHOLDER_TOKEN="REPLACE_WITH_REAL_TOKEN_$(date +%s)"
      
      # Delete old secret if exists
      if [ "$SECRET_EXISTS" = true ]; then
        echo "   Deleting old k8s secret..."
        kubectl delete secret coder-admin-api-token -n coder >/dev/null 2>&1 || true
      fi
      
      # Create new secret with placeholder
      kubectl create secret generic coder-admin-api-token \
        --from-literal=token="$PLACEHOLDER_TOKEN" \
        -n coder

      echo "   ðŸ’¾ Placeholder secret created"
      echo ""
      echo "ðŸš¨ MANUAL ACTION REQUIRED:"
      echo "1. Visit: $CODER_URL"
      echo "2. Log in as admin user: $FIRST_USER_EMAIL"
      echo "3. Go to Account â†’ Tokens"
      echo "4. Create new token: '$TOKEN_NAME'"
      echo "5. Replace placeholder:"
      echo "   kubectl patch secret coder-admin-api-token -n coder \\"
      echo "     -p '{\"data\":{\"token\":\"BASE64_ENCODED_TOKEN\"}}'"
      echo ""
      echo "6. Restart this job to continue automation:"
      echo "   kubectl delete job coder-template-init -n coder"
      echo ""
      echo "ðŸ”„ Job will exit now - restart after manual token creation"
      exit 0
    fi

    echo "ðŸŽ¯ Using admin token ending with: ${ADMIN_TOKEN: -8}"

    # Test API token
    echo "Testing API authentication..."
    AUTH_TEST=$(curl -s -H "Coder-Session-Token: $ADMIN_TOKEN" "$CODER_URL/api/v2/users/me")
    if echo "$AUTH_TEST" | grep -q '"id"'; then
      echo "Authentication successful!"
    else
      echo "ERROR: API authentication failed"
      echo "Response: $AUTH_TEST"
      exit 1
    fi

    # Create template tar from ConfigMap files
    echo "Preparing template files..."
    cd /template-files
    
    # Verify required files exist
    if [ ! -f "main.tf" ]; then
      echo "ERROR: main.tf not found in ConfigMap"
      exit 1
    fi
    
    if [ ! -f "README.md" ]; then
      echo "ERROR: README.md not found in ConfigMap"
      exit 1
    fi
    
    # Create tar.gz for upload
    tar -czf /tmp/template.tar.gz .
    echo "Template archive created: $(ls -lh /tmp/template.tar.gz)"

    # Upload template files
    echo "Uploading template files..."
    UPLOAD_RESPONSE=$(curl -s -X POST "$CODER_URL/api/v2/files" \
      -H "Content-Type: application/x-tar" \
      -H "Coder-Session-Token: $ADMIN_TOKEN" \
      --data-binary @/tmp/template.tar.gz)

    echo "Upload response: $UPLOAD_RESPONSE"

    # Extract file ID
    FILE_ID=$(echo "$UPLOAD_RESPONSE" | grep -o '"hash":"[^"]*"' | sed 's/"hash":"//;s/"//')
    if [ -z "$FILE_ID" ]; then
      echo "ERROR: Failed to extract file ID from upload response"
      echo "Response: $UPLOAD_RESPONSE"
      exit 1
    fi

    echo "File uploaded successfully. ID: $FILE_ID"

    # Check if template already exists
    echo "Checking for existing template..."
    TEMPLATES_RESPONSE=$(curl -s -H "Coder-Session-Token: $ADMIN_TOKEN" "$CODER_URL/api/v2/organizations/coder/templates")
    TEMPLATE_ID=$(echo "$TEMPLATES_RESPONSE" | grep -o "\"id\":\"[^\"]*\",\"created_at\":[^,]*,\"updated_at\":[^,]*,\"organization_id\":\"[^\"]*\",\"name\":\"$TEMPLATE_NAME\"" | sed 's/"id":"//;s/",.*$//')

    if [ -n "$TEMPLATE_ID" ]; then
      echo "Found existing template: $TEMPLATE_ID"
      
      # Create new version for existing template
      echo "Creating new template version..."
      VERSION_RESPONSE=$(curl -s -X POST "$CODER_URL/api/v2/organizations/coder/templateversions" \
        -H "Content-Type: application/json" \
        -H "Coder-Session-Token: $ADMIN_TOKEN" \
        -d "{
          \"file_id\": \"$FILE_ID\",
          \"name\": \"$VERSION_NAME\",
          \"template_id\": \"$TEMPLATE_ID\",
          \"message\": \"GitOps automated update with GitHub external auth\"
        }")
        
    else
      echo "Creating new template..."
      # Create template and first version
      TEMPLATE_RESPONSE=$(curl -s -X POST "$CODER_URL/api/v2/organizations/coder/templates" \
        -H "Content-Type: application/json" \
        -H "Coder-Session-Token: $ADMIN_TOKEN" \
        -d "{
          \"name\": \"$TEMPLATE_NAME\",
          \"display_name\": \"Kubernetes (Devcontainer) - GitOps\",
          \"description\": \"Devcontainer workspaces with GitHub external auth - Deployed via GitOps\",
          \"file_id\": \"$FILE_ID\",
          \"version_name\": \"$VERSION_NAME\",
          \"message\": \"Initial GitOps template deployment with GitHub external auth\"
        }")
      
      echo "Template creation response: $TEMPLATE_RESPONSE"
      TEMPLATE_ID=$(echo "$TEMPLATE_RESPONSE" | grep -o '"id":"[^"]*"' | head -1 | sed 's/"id":"//;s/"//')
      VERSION_RESPONSE="$TEMPLATE_RESPONSE"
    fi

    echo "Version response: $VERSION_RESPONSE"

    # Extract version ID
    VERSION_ID=$(echo "$VERSION_RESPONSE" | grep -o '"id":"[^"]*"' | head -1 | sed 's/"id":"//;s/"//')
    if [ -z "$VERSION_ID" ]; then
      echo "ERROR: Failed to extract version ID"
      echo "Response: $VERSION_RESPONSE"
      exit 1
    fi

    echo "Template version created: $VERSION_ID"

    # Set as active version
    echo "Setting template version as active..."
    ACTIVE_RESPONSE=$(curl -s -X PATCH "$CODER_URL/api/v2/templates/$TEMPLATE_ID/versions" \
      -H "Content-Type: application/json" \
      -H "Coder-Session-Token: $ADMIN_TOKEN" \
      -d "{\"id\": \"$VERSION_ID\"}")

    echo "Active version response: $ACTIVE_RESPONSE"

    # Trigger dry run for statistics
    echo "Triggering template build for statistics..."
    BUILD_RESPONSE=$(curl -s -X POST "$CODER_URL/api/v2/templateversions/$VERSION_ID/dry-run" \
      -H "Content-Type: application/json" \
      -H "Coder-Session-Token: $ADMIN_TOKEN" \
      -d '{
        "workspace_name": "gitops-build-test",
        "rich_parameter_values": [
          {"name": "cpu", "value": "2"},
          {"name": "memory", "value": "2"},
          {"name": "workspaces_volume_size", "value": "10"},
          {"name": "repo", "value": "https://github.com/coder/envbuilder-starter-devcontainer"},
          {"name": "fallback_image", "value": "codercom/enterprise-base:ubuntu"},
          {"name": "devcontainer_builder", "value": "ghcr.io/coder/envbuilder:latest"}
        ]
      }')

    echo "Build statistics response: $BUILD_RESPONSE"

    # Verification
    echo "=== Template Deployment Complete ==="
    echo "Template Name: $TEMPLATE_NAME"
    echo "Template ID: $TEMPLATE_ID"
    echo "Active Version: $VERSION_ID ($VERSION_NAME)"
    echo "URL: $CODER_URL/templates/$TEMPLATE_NAME"
    
    echo ""
    echo "âœ… GitOps template automation successful!"
    echo "âœ… GitHub external authentication configured"
    echo "âœ… Namespace deployment fixed (coder namespace)"
    echo "âœ… Template ready for workspace creation"
    
    echo ""
    echo "Next steps:"
    echo "1. Create workspace using this template"
    echo "2. Provide repository URL for devcontainer build"
    echo "3. Link GitHub account for private repository access"
    echo "4. Test complete workflow end-to-end"