---
apiVersion: v1
kind: ConfigMap
metadata:
  name: coder-template-init-script
  namespace: coder
  labels:
    app.kubernetes.io/name: coder-template-init-script
    app.kubernetes.io/component: template-automation
    app.kubernetes.io/managed-by: flux
data:
  template-init.sh: |
    #!/bin/sh
    set -e

    # Template automation script for Coder GitOps deployment
    # Following the proven Gitea pattern for automatic token management

    CODER_URL="https://coder.xuperson.org"
    TEMPLATE_NAME="kubernetes-devcontainer"
    VERSION_NAME="gitops-$(date +%Y%m%d-%H%M%S)"
    TOKEN_NAME="template-automation"

    echo "🏗️ Setting up Coder template automation..."
    echo "URL: $CODER_URL"
    echo "Template: $TEMPLATE_NAME"
    echo "Version: $VERSION_NAME"

    # Wait for Coder to be ready
    echo "📡 Waiting for Coder to be ready..."
    for i in $(seq 1 60); do
      if curl -s -f "$CODER_URL/healthz" >/dev/null 2>&1; then
        echo "✅ Coder is ready!"
        break
      fi
      echo "   Attempt $i/60: Coder not ready, waiting..."
      sleep 10
    done

    # Final health check
    if ! curl -s -f "$CODER_URL/healthz" >/dev/null 2>&1; then
      echo "❌ ERROR: Coder failed to become ready after 10 minutes"
      exit 1
    fi

    # Automatic token management (following Gitea pattern)
    echo "🔑 Managing Coder admin API token with fixed naming..."
    
    # Test kubectl access
    echo "   Testing kubectl access..."
    if ! kubectl get secrets -n coder >/dev/null 2>&1; then
      echo "   ❌ kubectl access failed"
      exit 1
    fi
    echo "   ✅ kubectl access confirmed"

    # Get admin credentials from first user (Coder auto-creates first user)
    echo "📋 Getting first admin user info..."
    USERS_RESPONSE=""
    for i in $(seq 1 30); do
      USERS_RESPONSE=$(curl -s "$CODER_URL/api/v2/users?limit=1" 2>/dev/null || echo "")
      if echo "$USERS_RESPONSE" | grep -q '"id"'; then
        break
      fi
      echo "   Attempt $i/30: No users yet, waiting for first user creation..."
      sleep 10
    done

    FIRST_USER_ID=$(echo "$USERS_RESPONSE" | grep -o '"id":"[^"]*"' | head -1 | sed 's/"id":"//;s/"//')
    FIRST_USER_EMAIL=$(echo "$USERS_RESPONSE" | grep -o '"email":"[^"]*"' | head -1 | sed 's/"email":"//;s/"//')
    
    if [ -z "$FIRST_USER_ID" ]; then
      echo "❌ ERROR: No users found in Coder"
      echo "   Please create the first admin user via web UI first"
      echo "   Visit: $CODER_URL"
      exit 1
    fi
    
    echo "✅ Found first user: $FIRST_USER_EMAIL (ID: $FIRST_USER_ID)"

    # Check for existing k8s secret
    SECRET_EXISTS=false
    K8S_TOKEN=""
    echo "   Checking for existing k8s secret..."
    if kubectl get secret coder-admin-api-token -n coder >/dev/null 2>&1; then
      K8S_TOKEN=$(kubectl get secret coder-admin-api-token -n coder -o jsonpath='{.data.token}' | base64 -d 2>/dev/null || echo "")
      if [ -n "$K8S_TOKEN" ] && [ ${#K8S_TOKEN} -gt 20 ]; then
        SECRET_EXISTS=true
        echo "   ✅ Found existing k8s secret with valid token"
      else
        echo "   ❌ Secret exists but token is invalid"
      fi
    else
      echo "   ❌ No k8s secret found"
    fi

    # Get list of existing tokens via internal API (using session approach)
    echo "   Checking existing API tokens in Coder..."
    
    # For fresh deployment, we need to bootstrap using session authentication
    # This follows the pattern from Gitea but adapted for Coder's API
    
    # Validate existing token if we have one
    TOKEN_VALID=false
    if [ "$SECRET_EXISTS" = true ]; then
      echo "   Validating existing token..."
      if curl -s -f -H "Coder-Session-Token: $K8S_TOKEN" "$CODER_URL/api/v2/users/me" >/dev/null 2>&1; then
        TOKEN_VALID=true
        echo "   ✅ Existing token is valid and working"
        ADMIN_TOKEN="$K8S_TOKEN"
      else
        echo "   ❌ Existing token is invalid or expired"
      fi
    fi

    # Create new token if needed
    if [ "$TOKEN_VALID" = false ]; then
      echo "🧹 Creating new API token..."
      
      # For bootstrap, we need to use the first user's authentication
      # In Coder, API tokens are created per-user, and first user is admin
      
      # Check if we can list tokens for first user (this might need session auth)
      echo "   Attempting to create API token for first user..."
      
      # Try to create token using internal API call
      # Note: This might require additional authentication setup in production
      
      # For now, create a placeholder that operators must replace
      echo "   Creating placeholder secret for manual token replacement..."
      
      # Generate a placeholder that clearly indicates manual action needed
      PLACEHOLDER_TOKEN="REPLACE_WITH_REAL_TOKEN_$(date +%s)"
      
      # Delete old secret if exists
      if [ "$SECRET_EXISTS" = true ]; then
        echo "   Deleting old k8s secret..."
        kubectl delete secret coder-admin-api-token -n coder >/dev/null 2>&1 || true
      fi
      
      # Create new secret with placeholder
      kubectl create secret generic coder-admin-api-token \
        --from-literal=token="$PLACEHOLDER_TOKEN" \
        -n coder

      echo "   💾 Placeholder secret created"
      echo ""
      echo "🚨 MANUAL ACTION REQUIRED:"
      echo "1. Visit: $CODER_URL"
      echo "2. Log in as admin user: $FIRST_USER_EMAIL"
      echo "3. Go to Account → Tokens"
      echo "4. Create new token: '$TOKEN_NAME'"
      echo "5. Replace placeholder:"
      echo "   kubectl patch secret coder-admin-api-token -n coder \\"
      echo "     -p '{\"data\":{\"token\":\"BASE64_ENCODED_TOKEN\"}}'"
      echo ""
      echo "6. Restart this job to continue automation:"
      echo "   kubectl delete job coder-template-init -n coder"
      echo ""
      echo "🔄 Job will exit now - restart after manual token creation"
      exit 0
    fi

    echo "🎯 Using admin token ending with: ${ADMIN_TOKEN: -8}"

    # Test API token
    echo "Testing API authentication..."
    AUTH_TEST=$(curl -s -H "Coder-Session-Token: $ADMIN_TOKEN" "$CODER_URL/api/v2/users/me")
    if echo "$AUTH_TEST" | grep -q '"id"'; then
      echo "Authentication successful!"
    else
      echo "ERROR: API authentication failed"
      echo "Response: $AUTH_TEST"
      exit 1
    fi

    # Create template tar from ConfigMap files
    echo "Preparing template files..."
    cd /template-files
    
    # Verify required files exist
    if [ ! -f "main.tf" ]; then
      echo "ERROR: main.tf not found in ConfigMap"
      exit 1
    fi
    
    if [ ! -f "README.md" ]; then
      echo "ERROR: README.md not found in ConfigMap"
      exit 1
    fi
    
    # Create tar.gz for upload
    tar -czf /tmp/template.tar.gz .
    echo "Template archive created: $(ls -lh /tmp/template.tar.gz)"

    # Upload template files
    echo "Uploading template files..."
    UPLOAD_RESPONSE=$(curl -s -X POST "$CODER_URL/api/v2/files" \
      -H "Content-Type: application/x-tar" \
      -H "Coder-Session-Token: $ADMIN_TOKEN" \
      --data-binary @/tmp/template.tar.gz)

    echo "Upload response: $UPLOAD_RESPONSE"

    # Extract file ID
    FILE_ID=$(echo "$UPLOAD_RESPONSE" | grep -o '"hash":"[^"]*"' | sed 's/"hash":"//;s/"//')
    if [ -z "$FILE_ID" ]; then
      echo "ERROR: Failed to extract file ID from upload response"
      echo "Response: $UPLOAD_RESPONSE"
      exit 1
    fi

    echo "File uploaded successfully. ID: $FILE_ID"

    # Check if template already exists
    echo "Checking for existing template..."
    TEMPLATES_RESPONSE=$(curl -s -H "Coder-Session-Token: $ADMIN_TOKEN" "$CODER_URL/api/v2/organizations/coder/templates")
    TEMPLATE_ID=$(echo "$TEMPLATES_RESPONSE" | grep -o "\"id\":\"[^\"]*\",\"created_at\":[^,]*,\"updated_at\":[^,]*,\"organization_id\":\"[^\"]*\",\"name\":\"$TEMPLATE_NAME\"" | sed 's/"id":"//;s/",.*$//')

    if [ -n "$TEMPLATE_ID" ]; then
      echo "Found existing template: $TEMPLATE_ID"
      
      # Create new version for existing template
      echo "Creating new template version..."
      VERSION_RESPONSE=$(curl -s -X POST "$CODER_URL/api/v2/organizations/coder/templateversions" \
        -H "Content-Type: application/json" \
        -H "Coder-Session-Token: $ADMIN_TOKEN" \
        -d "{
          \"file_id\": \"$FILE_ID\",
          \"name\": \"$VERSION_NAME\",
          \"template_id\": \"$TEMPLATE_ID\",
          \"message\": \"GitOps automated update with GitHub external auth\"
        }")
        
    else
      echo "Creating new template..."
      # Create template and first version
      TEMPLATE_RESPONSE=$(curl -s -X POST "$CODER_URL/api/v2/organizations/coder/templates" \
        -H "Content-Type: application/json" \
        -H "Coder-Session-Token: $ADMIN_TOKEN" \
        -d "{
          \"name\": \"$TEMPLATE_NAME\",
          \"display_name\": \"Kubernetes (Devcontainer) - GitOps\",
          \"description\": \"Devcontainer workspaces with GitHub external auth - Deployed via GitOps\",
          \"file_id\": \"$FILE_ID\",
          \"version_name\": \"$VERSION_NAME\",
          \"message\": \"Initial GitOps template deployment with GitHub external auth\"
        }")
      
      echo "Template creation response: $TEMPLATE_RESPONSE"
      TEMPLATE_ID=$(echo "$TEMPLATE_RESPONSE" | grep -o '"id":"[^"]*"' | head -1 | sed 's/"id":"//;s/"//')
      VERSION_RESPONSE="$TEMPLATE_RESPONSE"
    fi

    echo "Version response: $VERSION_RESPONSE"

    # Extract version ID
    VERSION_ID=$(echo "$VERSION_RESPONSE" | grep -o '"id":"[^"]*"' | head -1 | sed 's/"id":"//;s/"//')
    if [ -z "$VERSION_ID" ]; then
      echo "ERROR: Failed to extract version ID"
      echo "Response: $VERSION_RESPONSE"
      exit 1
    fi

    echo "Template version created: $VERSION_ID"

    # Set as active version
    echo "Setting template version as active..."
    ACTIVE_RESPONSE=$(curl -s -X PATCH "$CODER_URL/api/v2/templates/$TEMPLATE_ID/versions" \
      -H "Content-Type: application/json" \
      -H "Coder-Session-Token: $ADMIN_TOKEN" \
      -d "{\"id\": \"$VERSION_ID\"}")

    echo "Active version response: $ACTIVE_RESPONSE"

    # Trigger dry run for statistics
    echo "Triggering template build for statistics..."
    BUILD_RESPONSE=$(curl -s -X POST "$CODER_URL/api/v2/templateversions/$VERSION_ID/dry-run" \
      -H "Content-Type: application/json" \
      -H "Coder-Session-Token: $ADMIN_TOKEN" \
      -d '{
        "workspace_name": "gitops-build-test",
        "rich_parameter_values": [
          {"name": "cpu", "value": "2"},
          {"name": "memory", "value": "2"},
          {"name": "workspaces_volume_size", "value": "10"},
          {"name": "repo", "value": "https://github.com/coder/envbuilder-starter-devcontainer"},
          {"name": "fallback_image", "value": "codercom/enterprise-base:ubuntu"},
          {"name": "devcontainer_builder", "value": "ghcr.io/coder/envbuilder:latest"}
        ]
      }')

    echo "Build statistics response: $BUILD_RESPONSE"

    # Verification
    echo "=== Template Deployment Complete ==="
    echo "Template Name: $TEMPLATE_NAME"
    echo "Template ID: $TEMPLATE_ID"
    echo "Active Version: $VERSION_ID ($VERSION_NAME)"
    echo "URL: $CODER_URL/templates/$TEMPLATE_NAME"
    
    echo ""
    echo "✅ GitOps template automation successful!"
    echo "✅ GitHub external authentication configured"
    echo "✅ Namespace deployment fixed (coder namespace)"
    echo "✅ Template ready for workspace creation"
    
    echo ""
    echo "Next steps:"
    echo "1. Create workspace using this template"
    echo "2. Provide repository URL for devcontainer build"
    echo "3. Link GitHub account for private repository access"
    echo "4. Test complete workflow end-to-end"