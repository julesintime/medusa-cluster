---
apiVersion: v1
kind: ConfigMap
metadata:
  name: coder-template-init-script
  namespace: coder
  labels:
    app.kubernetes.io/name: coder-template-init-script
    app.kubernetes.io/component: template-automation
    app.kubernetes.io/managed-by: flux
data:
  template-init.sh: |
    #!/bin/sh
    set -e

    # Template automation script following Gitea pattern
    # FULLY AUTOMATIC token creation - NO MANUAL STEPS

    CODER_URL="https://coder.xuperson.org"
    TEMPLATE_NAME="kubernetes-devcontainer"
    VERSION_NAME="gitops-$(date +%Y%m%d-%H%M%S)"
    TOKEN_NAME="template-automation"

    echo "ğŸ—ï¸ Setting up Coder template automation..."
    echo "URL: $CODER_URL"
    echo "Template: $TEMPLATE_NAME" 
    echo "Version: $VERSION_NAME"

    # Wait for Coder to be ready
    echo "ğŸ“¡ Waiting for Coder to be ready..."
    for i in $(seq 1 60); do
      if curl -s -f "$CODER_URL/healthz" >/dev/null 2>&1; then
        echo "âœ… Coder is ready!"
        break
      fi
      echo "   Attempt $i/60: Coder not ready, waiting..."
      sleep 10
    done

    if ! curl -s -f "$CODER_URL/healthz" >/dev/null 2>&1; then
      echo "âŒ ERROR: Coder failed to become ready after 10 minutes"
      exit 1
    fi

    # Automatic token management (following Gitea pattern exactly)
    echo "ğŸ”‘ Managing Coder admin API token with fixed naming..."
    
    # Test kubectl access
    echo "   Testing kubectl access..."
    if ! kubectl get secrets -n coder >/dev/null 2>&1; then
      echo "   âŒ kubectl access failed"
      exit 1
    fi
    echo "   âœ… kubectl access confirmed"

    # Check for existing k8s secret
    SECRET_EXISTS=false
    K8S_TOKEN=""
    echo "   Checking for existing k8s secret..."
    if kubectl get secret coder-admin-api-token -n coder >/dev/null 2>&1; then
      K8S_TOKEN=$(kubectl get secret coder-admin-api-token -n coder -o jsonpath='{.data.token}' | base64 -d 2>/dev/null || echo "")
      if [ -n "$K8S_TOKEN" ] && [ ${#K8S_TOKEN} -gt 20 ]; then
        SECRET_EXISTS=true
        echo "   âœ… Found existing k8s secret with valid token"
      else
        echo "   âŒ Secret exists but token is invalid"
      fi
    else
      echo "   âŒ No k8s secret found"
    fi

    # Validate existing token if we have one
    TOKEN_VALID=false
    if [ "$SECRET_EXISTS" = true ]; then
      echo "   Validating existing token..."
      if curl -s -f -H "Coder-Session-Token: $K8S_TOKEN" "$CODER_URL/api/v2/users/me" >/dev/null 2>&1; then
        TOKEN_VALID=true
        echo "   âœ… Existing token is valid and working"
        ADMIN_TOKEN="$K8S_TOKEN"
      else
        echo "   âŒ Existing token is invalid or expired"
      fi
    fi

    # Create new token if needed - AUTOMATIC like Gitea
    if [ "$TOKEN_VALID" = false ]; then
      echo "ğŸ§¹ Creating new API token AUTOMATICALLY..."
      
      # Wait for first user to exist (Coder creates default admin)
      echo "   Waiting for first admin user..."
      FIRST_USER_ID=""
      FIRST_USER_EMAIL=""
      
      for i in $(seq 1 30); do
        USERS_RESPONSE=$(curl -s "$CODER_URL/api/v2/users?limit=1" 2>/dev/null || echo "")
        FIRST_USER_ID=$(echo "$USERS_RESPONSE" | grep -o '"id":"[^"]*"' | head -1 | sed 's/"id":"//;s/"//')
        FIRST_USER_EMAIL=$(echo "$USERS_RESPONSE" | grep -o '"email":"[^"]*"' | head -1 | sed 's/"email":"//;s/"//')
        
        if [ -n "$FIRST_USER_ID" ]; then
          echo "   âœ… Found first admin user: $FIRST_USER_EMAIL"
          break
        fi
        echo "   Attempt $i/30: No users yet, waiting for first user creation..."
        sleep 10
      done

      if [ -z "$FIRST_USER_ID" ]; then
        echo "âŒ ERROR: No admin user found after 5 minutes"
        echo "   Create first admin user at: $CODER_URL"
        exit 1
      fi

      # Clean up old tokens and secret (following Gitea pattern)
      echo "   Cleaning up old tokens..."
      if [ "$SECRET_EXISTS" = true ]; then
        echo "   Deleting old k8s secret..."
        kubectl delete secret coder-admin-api-token -n coder >/dev/null 2>&1 || true
      fi

      # CRITICAL: Use Coder's bootstrap API for first admin
      # For fresh deployments, first user has special bootstrap privileges
      echo "   Creating token using bootstrap privileges..."
      
      # Try the special bootstrap endpoint first (if exists)
      TOKEN_RESPONSE=$(curl -s -X POST "$CODER_URL/api/v2/users/$FIRST_USER_ID/tokens" \
        -H "Content-Type: application/json" \
        -H "Accept: application/json" \
        -d "{
          \"lifetime\": 8760,
          \"scope\": \"all\", 
          \"token_name\": \"$TOKEN_NAME\"
        }" 2>/dev/null || echo "")

      # Extract token from response
      ADMIN_TOKEN=$(echo "$TOKEN_RESPONSE" | grep -o '"key":"[^"]*"' | sed 's/"key":"//;s/"//')

      # If bootstrap API fails, try session-based approach
      if [ -z "$ADMIN_TOKEN" ]; then
        echo "   Bootstrap API failed, trying session approach..."
        
        # For Coder, we can use the CLI token creation approach
        # This works because first user has admin privileges
        SESSION_RESPONSE=$(curl -s -X POST "$CODER_URL/api/v2/authtoken" \
          -H "Content-Type: application/json" \
          -d "{\"email\":\"$FIRST_USER_EMAIL\"}" 2>/dev/null || echo "")
        
        if echo "$SESSION_RESPONSE" | grep -q "session_token"; then
          SESSION_TOKEN=$(echo "$SESSION_RESPONSE" | grep -o '"session_token":"[^"]*"' | sed 's/"session_token":"//;s/"//')
          
          # Now create token with session
          TOKEN_RESPONSE=$(curl -s -X POST "$CODER_URL/api/v2/users/$FIRST_USER_ID/tokens" \
            -H "Content-Type: application/json" \
            -H "Coder-Session-Token: $SESSION_TOKEN" \
            -d "{
              \"lifetime\": 8760,
              \"scope\": \"all\",
              \"token_name\": \"$TOKEN_NAME\"
            }")
          
          ADMIN_TOKEN=$(echo "$TOKEN_RESPONSE" | grep -o '"key":"[^"]*"' | sed 's/"key":"//;s/"//')
        fi
      fi

      if [ -z "$ADMIN_TOKEN" ]; then
        echo "   âŒ Automatic token creation failed"
        echo "   Token Response: $TOKEN_RESPONSE"
        echo ""
        echo "ğŸš¨ MANUAL FALLBACK REQUIRED:"
        echo "1. Visit: $CODER_URL"
        echo "2. Create first admin user if not exists"
        echo "3. Account â†’ Tokens â†’ Create '$TOKEN_NAME'"
        echo "4. Store token:"
        echo "   kubectl create secret generic coder-admin-api-token \\"
        echo "     --from-literal=token=\"YOUR_TOKEN\" -n coder"
        echo "5. Restart: kubectl delete job coder-template-init -n coder"
        exit 1
      fi

      echo "   âœ… Token created automatically (length: ${#ADMIN_TOKEN})"

      # Store in k8s secret
      echo "   Storing token in k8s secret..."
      if kubectl create secret generic coder-admin-api-token \
        --from-literal=token="$ADMIN_TOKEN" \
        -n coder \
        --dry-run=client -o yaml | kubectl apply -f - >/dev/null 2>&1; then
        echo "   âœ… Token stored successfully"
      else
        echo "   âŒ Failed to store token"
        exit 1
      fi

      echo "âœ… Token automation complete!"
    fi

    echo "ğŸ¯ Using admin token ending with: ${ADMIN_TOKEN: -8}"

    # Test API authentication
    echo "   Testing API authentication..."
    AUTH_TEST=$(curl -s -H "Coder-Session-Token: $ADMIN_TOKEN" "$CODER_URL/api/v2/users/me")
    if echo "$AUTH_TEST" | grep -q '"id"'; then
      echo "   âœ… Authentication successful!"
    else
      echo "   âŒ API authentication failed"
      echo "   Response: $AUTH_TEST"
      exit 1
    fi

    # Create template tar from ConfigMap files
    echo "ğŸ“¦ Preparing template files..."
    cd /template-files
    
    if [ ! -f "main.tf" ] || [ ! -f "README.md" ]; then
      echo "âŒ Template files missing in ConfigMap"
      exit 1
    fi
    
    tar -czf /tmp/template.tar.gz .
    echo "   âœ… Template archive created"

    # Upload template files
    echo "ğŸ“¤ Uploading template files..."
    UPLOAD_RESPONSE=$(curl -s -X POST "$CODER_URL/api/v2/files" \
      -H "Content-Type: application/x-tar" \
      -H "Coder-Session-Token: $ADMIN_TOKEN" \
      --data-binary @/tmp/template.tar.gz)

    FILE_ID=$(echo "$UPLOAD_RESPONSE" | grep -o '"hash":"[^"]*"' | sed 's/"hash":"//;s/"//')
    if [ -z "$FILE_ID" ]; then
      echo "âŒ Failed to upload template"
      echo "Response: $UPLOAD_RESPONSE"
      exit 1
    fi

    echo "   âœ… Files uploaded (ID: $FILE_ID)"

    # Check for existing template
    echo "ğŸ” Checking for existing template..."
    TEMPLATES_RESPONSE=$(curl -s -H "Coder-Session-Token: $ADMIN_TOKEN" "$CODER_URL/api/v2/organizations/coder/templates")
    TEMPLATE_ID=$(echo "$TEMPLATES_RESPONSE" | grep -o "\"id\":\"[^\"]*\",\"created_at\":[^,]*,\"updated_at\":[^,]*,\"organization_id\":\"[^\"]*\",\"name\":\"$TEMPLATE_NAME\"" | sed 's/"id":"//;s/",.*$//')

    if [ -n "$TEMPLATE_ID" ]; then
      echo "   âœ… Found existing template: $TEMPLATE_ID"
      
      # Create new version
      VERSION_RESPONSE=$(curl -s -X POST "$CODER_URL/api/v2/organizations/coder/templateversions" \
        -H "Content-Type: application/json" \
        -H "Coder-Session-Token: $ADMIN_TOKEN" \
        -d "{
          \"file_id\": \"$FILE_ID\",
          \"name\": \"$VERSION_NAME\",
          \"template_id\": \"$TEMPLATE_ID\",
          \"message\": \"GitOps automated update with GitHub external auth\"
        }")
    else
      echo "   ğŸ†• Creating new template..."
      
      # Create template and first version
      TEMPLATE_RESPONSE=$(curl -s -X POST "$CODER_URL/api/v2/organizations/coder/templates" \
        -H "Content-Type: application/json" \
        -H "Coder-Session-Token: $ADMIN_TOKEN" \
        -d "{
          \"name\": \"$TEMPLATE_NAME\",
          \"display_name\": \"Kubernetes (Devcontainer) - GitOps\",
          \"description\": \"Devcontainer workspaces with GitHub external auth\",
          \"file_id\": \"$FILE_ID\",
          \"version_name\": \"$VERSION_NAME\",
          \"message\": \"GitOps template with GitHub external auth\"
        }")
      
      TEMPLATE_ID=$(echo "$TEMPLATE_RESPONSE" | grep -o '"id":"[^"]*"' | head -1 | sed 's/"id":"//;s/"//')
      VERSION_RESPONSE="$TEMPLATE_RESPONSE"
    fi

    # Extract version ID and set as active
    VERSION_ID=$(echo "$VERSION_RESPONSE" | grep -o '"id":"[^"]*"' | head -1 | sed 's/"id":"//;s/"//')
    if [ -z "$VERSION_ID" ]; then
      echo "âŒ Failed to create template version"
      echo "Response: $VERSION_RESPONSE"
      exit 1
    fi

    echo "   âœ… Template version created: $VERSION_ID"

    # Set as active version
    echo "ğŸš€ Setting template as active..."
    curl -s -X PATCH "$CODER_URL/api/v2/templates/$TEMPLATE_ID/versions" \
      -H "Content-Type: application/json" \
      -H "Coder-Session-Token: $ADMIN_TOKEN" \
      -d "{\"id\": \"$VERSION_ID\"}" >/dev/null

    # Trigger build for statistics
    echo "ğŸ“Š Generating build statistics..."
    curl -s -X POST "$CODER_URL/api/v2/templateversions/$VERSION_ID/dry-run" \
      -H "Content-Type: application/json" \
      -H "Coder-Session-Token: $ADMIN_TOKEN" \
      -d '{
        "workspace_name": "build-test",
        "rich_parameter_values": [
          {"name": "cpu", "value": "2"},
          {"name": "memory", "value": "2"},
          {"name": "workspaces_volume_size", "value": "10"},
          {"name": "repo", "value": "https://github.com/coder/envbuilder-starter-devcontainer"}
        ]
      }' >/dev/null

    echo ""
    echo "ğŸ‰ Template automation complete!"
    echo "âœ… Template: $TEMPLATE_NAME"
    echo "âœ… Version: $VERSION_NAME"
    echo "âœ… GitHub external auth enabled"
    echo "âœ… Ready for workspace creation!"
    echo ""
    echo "ğŸŒ Access: $CODER_URL"
    echo "ğŸ“‹ Next: Create workspace â†’ Select template â†’ Provide repository URL"