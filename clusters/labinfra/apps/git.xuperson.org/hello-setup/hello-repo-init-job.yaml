---
apiVersion: v1
kind: ConfigMap
metadata:
  name: hello-repo-setup-script
  namespace: gitea
  labels:
    app.kubernetes.io/name: hello-repo-setup
    app.kubernetes.io/component: repository-management
    app.kubernetes.io/managed-by: flux
data:
  hello-repo-setup.sh: |
    #!/bin/sh
    set -e

    echo "🏗️ Setting up hello demo repository in Gitea..."

    # Get admin credentials
    ADMIN_USER=$(/usr/local/bin/kubectl get secret gitea-admin-secrets -n gitea -o jsonpath='{.data.username}' | base64 -d)
    ADMIN_PASS=$(/usr/local/bin/kubectl get secret gitea-admin-secrets -n gitea -o jsonpath='{.data.password}' | base64 -d)

    # Test Gitea API connection
    echo "📡 Testing Gitea API connection..."
    until curl -s -f -u "$ADMIN_USER:$ADMIN_PASS" "http://gitea-http:3000/api/v1/version" >/dev/null; do
      echo "   Gitea API not ready, waiting 5 seconds..."
      sleep 5
    done
    echo "✅ Gitea API is accessible"

    # Smart token management: ensure single token consistency between k8s and Gitea
    echo "🔑 Managing admin API token with consistency checks..."
    
    # Test kubectl access
    echo "   Testing kubectl access..."
    if ! /usr/local/bin/kubectl get secrets -n gitea >/dev/null 2>&1; then
      echo "   ❌ kubectl access failed"
      exit 1
    fi
    echo "   ✅ kubectl access confirmed"
    
    SECRET_EXISTS=false
    K8S_TOKEN=""
    echo "   Checking for existing k8s secret..."
    if /usr/local/bin/kubectl get secret gitea-admin-api-token -n gitea >/dev/null 2>&1; then
      SECRET_EXISTS=true
      K8S_TOKEN=$(/usr/local/bin/kubectl get secret gitea-admin-api-token -n gitea -o jsonpath='{.data.token}' | base64 -d 2>/dev/null)
      if [ -n "$K8S_TOKEN" ]; then
        echo "   ✅ Found existing k8s secret with token (length: ${#K8S_TOKEN})"
      else
        echo "   ❌ Secret exists but token is empty"
        SECRET_EXISTS=false
      fi
    else
      echo "   ❌ No k8s secret found"
    fi
    
    # Get existing tokens from Gitea
    echo "   Checking Gitea for existing tokens..."
    TOKENS_RESPONSE=$(curl -s -u "$ADMIN_USER:$ADMIN_PASS" "http://gitea-http:3000/api/v1/users/$ADMIN_USER/tokens")
    echo "   Raw API response: $TOKENS_RESPONSE"
    
    # Parse tokens from JSON response - try multiple approaches
    GITEA_TOKENS=""
    
    # Method 1: Look for sha1 in JSON
    if echo "$TOKENS_RESPONSE" | grep -q '"sha1":"[^"]*[^"]' | head -1; then
      # Only proceed if we find non-empty sha1 values
      GITEA_TOKENS=$(echo "$TOKENS_RESPONSE" | grep -o '"sha1":"[^"]*[^"]' | sed 's/"sha1":"//;s/"//' | tr '\n' ' ')
      echo "   Method 1 - Found tokens with SHA1: $GITEA_TOKENS"
    fi
    
    # Method 2: If method 1 failed, try alternative parsing
    if [ -z "$GITEA_TOKENS" ] && echo "$TOKENS_RESPONSE" | grep -q '"name"'; then
      echo "   Method 2 - SHA1 parsing failed, trying name-based parsing..."
      # Extract token names and assume we need to delete them
      TOKEN_NAMES=$(echo "$TOKENS_RESPONSE" | grep -o '"name":"[^"]*"' | sed 's/"name":"//;s/"//' | tr '\n' ' ')
      echo "   Found token names: $TOKEN_NAMES"
      if [ -n "$TOKEN_NAMES" ]; then
        GITEA_TOKENS="force_delete_all"
      fi
    fi
    
    TOKEN_COUNT=0
    if [ -n "$GITEA_TOKENS" ]; then
      if [ "$GITEA_TOKENS" = "force_delete_all" ]; then
        TOKEN_COUNT=$(echo "$TOKEN_NAMES" | wc -w)
        echo "   Found $TOKEN_COUNT token(s) in Gitea (names: $TOKEN_NAMES)"
        GITEA_TOKEN_LAST8="unknown"
      else
        TOKEN_COUNT=$(echo "$GITEA_TOKENS" | wc -w)
        echo "   Found $TOKEN_COUNT token(s) in Gitea: $GITEA_TOKENS"
        GITEA_TOKEN_LAST8=$(echo "$GITEA_TOKENS" | awk '{print $1}' | tail -c 9)
      fi
    else
      echo "   No tokens found in Gitea"
      GITEA_TOKEN_LAST8=""
    fi
    
    # Decision logic for token management
    if [ "$SECRET_EXISTS" = false ] && [ -z "$GITEA_TOKENS" ]; then
      echo "   Scenario: No secret, no tokens → Create new token"
      CREATE_NEW=true
    elif [ "$SECRET_EXISTS" = true ] && [ -z "$GITEA_TOKENS" ]; then
      echo "   Scenario: Secret exists, no tokens → Delete secret, create new token"
      /usr/local/bin/kubectl delete secret gitea-admin-api-token -n gitea >/dev/null 2>&1
      CREATE_NEW=true
    elif [ "$SECRET_EXISTS" = false ] && [ -n "$GITEA_TOKENS" ]; then
      echo "   Scenario: No secret, tokens exist → Delete all tokens, create new token"
      # Delete all existing tokens
      if [ "$GITEA_TOKENS" = "force_delete_all" ]; then
        # Try to delete by token name (Gitea API might accept names)
        for token_name in $TOKEN_NAMES; do
          if [ -n "$token_name" ]; then
            echo "   Attempting to delete token: $token_name"
            # Try deleting by name first
            if curl -s -X DELETE -u "$ADMIN_USER:$ADMIN_PASS" "http://gitea-http:3000/api/v1/users/$ADMIN_USER/tokens/$token_name" >/dev/null 2>&1; then
              echo "   ✅ Deleted token: $token_name"
            else
              echo "   ❌ Failed to delete token: $token_name"
            fi
          fi
        done
      fi
      CREATE_NEW=true
    else
      # Both exist - compare last 8 digits
      K8S_TOKEN_LAST8=$(echo "$K8S_TOKEN" | tail -c 9)
      if [ "$K8S_TOKEN_LAST8" = "$GITEA_TOKEN_LAST8" ]; then
        echo "   Scenario: Tokens match (last 8: $K8S_TOKEN_LAST8) → Use existing token"
        ADMIN_TOKEN="$K8S_TOKEN"
        CREATE_NEW=false
      else
        echo "   Scenario: Token mismatch (k8s: $K8S_TOKEN_LAST8, gitea: $GITEA_TOKEN_LAST8) → Delete and recreate"
        # Delete existing tokens
        if [ "$GITEA_TOKENS" = "force_delete_all" ]; then
          # Delete by token name
          for token_name in $TOKEN_NAMES; do
            if [ -n "$token_name" ]; then
              echo "   Deleting token by name: $token_name"
              TOKEN_INFO=$(curl -s -u "$ADMIN_USER:$ADMIN_PASS" "http://gitea-http:3000/api/v1/users/$ADMIN_USER/tokens")
              TOKEN_SHA1=$(echo "$TOKEN_INFO" | grep -A5 "\"name\":\"$token_name\"" | head -1 | grep -o '"sha1":"[^"]*"' | sed 's/"sha1":"//;s/"//')
              if [ -n "$TOKEN_SHA1" ]; then
                curl -s -X DELETE -u "$ADMIN_USER:$ADMIN_PASS" "http://gitea-http:3000/api/v1/users/$ADMIN_USER/tokens/$TOKEN_SHA1" >/dev/null
                echo "   Deleted token: ${TOKEN_SHA1: -8}"
              fi
            fi
          done
        else
          # Delete by SHA1
          for token_sha1 in $GITEA_TOKENS; do
            if [ -n "$token_sha1" ]; then
              echo "   Deleting token: ${token_sha1: -8}"
              curl -s -X DELETE -u "$ADMIN_USER:$ADMIN_PASS" "http://gitea-http:3000/api/v1/users/$ADMIN_USER/tokens/$token_sha1" >/dev/null
            fi
          done
        fi
        /usr/local/bin/kubectl delete secret gitea-admin-api-token -n gitea >/dev/null 2>&1
        CREATE_NEW=true
      fi
    fi
    
    # Create new token if needed
    if [ "$CREATE_NEW" = true ]; then
      echo "🏗️ Creating new admin API token..."
      TOKEN_NAME="repo-automation-$(date +%s)"
      RESPONSE=$(curl -s -X POST "http://gitea-http:3000/api/v1/users/$ADMIN_USER/tokens" \
        -H "Content-Type: application/json" \
        -u "$ADMIN_USER:$ADMIN_PASS" \
        -d "{\"name\": \"$TOKEN_NAME\", \"scopes\": [\"all\"]}")
      
      # Extract the full token from response (Gitea API returns full token on creation)
      ADMIN_TOKEN=$(echo "$RESPONSE" | grep -o '"sha1":"[^"]*"' | sed 's/"sha1":"//;s/"//')
      
      if [ -z "$ADMIN_TOKEN" ] || [ ${#ADMIN_TOKEN} -ne 40 ]; then
        echo "❌ Failed to create new token"
        exit 1
      fi
      
      # Store in k8s secret
      echo "   Storing token in k8s secret..."
      if /usr/local/bin/kubectl create secret generic gitea-admin-api-token \
        --from-literal=token="$ADMIN_TOKEN" \
        -n gitea \
        --dry-run=client -o yaml | /usr/local/bin/kubectl apply -f - >/dev/null 2>&1; then
        echo "   ✅ Token stored successfully in k8s secret"
      else
        echo "   ❌ Failed to store token in k8s secret"
        exit 1
      fi
      
      echo "✅ Created and stored new token (length: ${#ADMIN_TOKEN})"
    fi
    
    echo "🎯 Using admin token ending with: ${ADMIN_TOKEN: -8}"

    # Check if hello repository already exists and delete if it does
    echo "📋 Checking if hello repository exists..."
    REPO_CHECK=$(curl -s -H "Authorization: token $ADMIN_TOKEN" "http://gitea-http:3000/api/v1/repos/$ADMIN_USER/hello" 2>/dev/null || echo "")

    if echo "$REPO_CHECK" | grep -q '"name":"hello"'; then
      echo "🔄 Repository 'hello' exists, deleting and recreating..."
      curl -s -X DELETE "http://gitea-http:3000/api/v1/repos/$ADMIN_USER/hello" \
        -H "Authorization: token $ADMIN_TOKEN" >/dev/null
      echo "✅ Repository 'hello' deleted successfully"
      sleep 2
    else
      echo "📝 Repository 'hello' does not exist, will create new one"
    fi

    # Always create fresh hello repository
    echo "🏗️ Creating fresh hello repository..."
    curl -s -X POST "http://gitea-http:3000/api/v1/user/repos" \
      -H "Authorization: token $ADMIN_TOKEN" \
      -H "Content-Type: application/json" \
      -d '{
        "name": "hello",
        "description": "Hello World CI/CD Demo",
        "private": false,
        "auto_init": true,
        "default_branch": "main"
      }' > /dev/null
    
    # Wait for repository to be created
    sleep 2
    echo "✅ Repository 'hello' created successfully"

    # Create temporary directory for repository operations
    TEMP_DIR="/tmp/hello-repo-setup"
    rm -rf "$TEMP_DIR"
    mkdir -p "$TEMP_DIR"
    cd "$TEMP_DIR"

    # Install git if not available
    if ! command -v git >/dev/null 2>&1; then
      echo "📦 Installing git..."
      apk add --no-cache git
    fi

    # Initialize git configuration
    git config --global user.name "$ADMIN_USER"
    git config --global user.email "$ADMIN_USER@xuperson.org"

    # Clone the repository (will be empty since we just created it)
    echo "📥 Cloning repository..."
    git clone "http://$ADMIN_USER:$ADMIN_PASS@gitea-http:3000/$ADMIN_USER/hello.git" .

    # Create project structure
    echo "📁 Creating project structure..."
    mkdir -p .gitea/workflows

    # Copy files from ConfigMaps
    echo "📋 Copying application files from ConfigMaps..."
    cp /app-code/package.json .
    cp /app-code/Dockerfile .
    cp /app-code/index.js .
    cp /app-code/README.md .
    cp /cicd-workflow/docker-buildx-ci.yml .gitea/workflows/







    # Add all files and commit
    echo "📝 Committing files..."
    git add .
    git commit -m "feat: fresh hello CI/CD demo setup

    - Ensure repository content always aligns with ConfigMaps
    - Add Node.js hello world application
    - Configure BuildKit CI/CD pipeline  
    - Include Dockerfile for containerization
    - Setup project structure and documentation

    🤖 Generated with GitOps automation - ConfigMap aligned"

    # Push to repository
    echo "📤 Pushing to repository..."
    git push origin main

    echo "✅ Hello repository setup completed successfully!"
    echo "🎯 Repository: http://gitea-http:3000/$ADMIN_USER/hello"
    echo "🔄 Actions will trigger automatically on push"

    # Clean up
    cd /
    rm -rf "$TEMP_DIR"

    echo "🎉 Setup complete! Check Gitea Actions for workflow execution."
---
apiVersion: batch/v1
kind: Job
metadata:
  name: hello-repo-setup
  namespace: gitea
  labels:
    app.kubernetes.io/name: hello-repo-setup
    app.kubernetes.io/component: repository-management
    app.kubernetes.io/managed-by: flux
spec:
  ttlSecondsAfterFinished: 300
  template:
    spec:
      restartPolicy: OnFailure
      serviceAccountName: gitea-runner-init  # Reuse existing service account
      initContainers:
      - name: install-kubectl
        image: bitnami/kubectl:latest
        command:
        - sh
        - -c
        - cp /opt/bitnami/kubectl/bin/kubectl /shared/kubectl && chmod +x /shared/kubectl
        volumeMounts:
        - name: kubectl-binary
          mountPath: /shared
      containers:
      - name: hello-repo-setup
        image: alpine/curl:latest
        command: ["/scripts/hello-repo-setup.sh"]
        volumeMounts:
        - name: script-volume
          mountPath: /scripts
        - name: kubectl-binary
          mountPath: /usr/local/bin/kubectl
          subPath: kubectl
        - name: app-code
          mountPath: /app-code
        - name: cicd-workflow
          mountPath: /cicd-workflow
        resources:
          requests:
            memory: "64Mi"
            cpu: "100m"
          limits:
            memory: "128Mi"
            cpu: "200m"
        env:
        - name: GIT_SSL_NO_VERIFY
          value: "1"
      volumes:
      - name: script-volume
        configMap:
          name: hello-repo-setup-script
          defaultMode: 0755
      - name: kubectl-binary
        emptyDir: {}
      - name: app-code
        configMap:
          name: hello-app-code
      - name: cicd-workflow
        configMap:
          name: hello-cicd-workflow