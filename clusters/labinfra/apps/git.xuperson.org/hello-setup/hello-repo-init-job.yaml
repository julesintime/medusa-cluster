---
apiVersion: v1
kind: ConfigMap
metadata:
  name: hello-repo-setup-script
  namespace: gitea
  labels:
    app.kubernetes.io/name: hello-repo-setup
    app.kubernetes.io/component: repository-management
    app.kubernetes.io/managed-by: flux
data:
  hello-repo-setup.sh: |
    #!/bin/sh
    set -e

    echo "ðŸ—ï¸ Setting up hello demo repository in Gitea..."

    # Get admin credentials
    ADMIN_USER=$(/usr/local/bin/kubectl get secret gitea-admin-secrets -n gitea -o jsonpath='{.data.username}' | base64 -d)
    ADMIN_PASS=$(/usr/local/bin/kubectl get secret gitea-admin-secrets -n gitea -o jsonpath='{.data.password}' | base64 -d)

    # Test Gitea API connection
    echo "ðŸ“¡ Testing Gitea API connection..."
    until curl -s -f -u "$ADMIN_USER:$ADMIN_PASS" "http://gitea-http:3000/api/v1/version" >/dev/null; do
      echo "   Gitea API not ready, waiting 5 seconds..."
      sleep 5
    done
    echo "âœ… Gitea API is accessible"

    # Smart token management: ensure single token consistency between k8s and Gitea
    echo "ðŸ”‘ Managing admin API token with consistency checks..."
    
    # Test kubectl access
    echo "   Testing kubectl access..."
    if ! /usr/local/bin/kubectl get secrets -n gitea >/dev/null 2>&1; then
      echo "   âŒ kubectl access failed"
      exit 1
    fi
    echo "   âœ… kubectl access confirmed"
    
    SECRET_EXISTS=false
    K8S_TOKEN=""
    echo "   Checking for existing k8s secret..."
    if /usr/local/bin/kubectl get secret gitea-admin-api-token -n gitea >/dev/null 2>&1; then
      SECRET_EXISTS=true
      K8S_TOKEN=$(/usr/local/bin/kubectl get secret gitea-admin-api-token -n gitea -o jsonpath='{.data.token}' | base64 -d 2>/dev/null)
      if [ -n "$K8S_TOKEN" ]; then
        echo "   âœ… Found existing k8s secret with token (length: ${#K8S_TOKEN})"
      else
        echo "   âŒ Secret exists but token is empty"
        SECRET_EXISTS=false
      fi
    else
      echo "   âŒ No k8s secret found"
    fi
    
    # Get existing tokens from Gitea
    echo "   Checking Gitea for existing tokens..."
    TOKENS_RESPONSE=$(curl -s -u "$ADMIN_USER:$ADMIN_PASS" "http://gitea-http:3000/api/v1/users/$ADMIN_USER/tokens")
    echo "   Raw API response: $TOKENS_RESPONSE"
    
    # Parse tokens from JSON response - try multiple approaches
    GITEA_TOKENS=""
    
    # Method 1: Look for sha1 in JSON
    if echo "$TOKENS_RESPONSE" | grep -q '"sha1"'; then
      GITEA_TOKENS=$(echo "$TOKENS_RESPONSE" | grep -o '"sha1":"[^"]*"' | sed 's/"sha1":"//;s/"//' | tr '\n' ' ')
      echo "   Method 1 - Found tokens: $GITEA_TOKENS"
    fi
    
    # Method 2: If method 1 failed, try alternative parsing
    if [ -z "$GITEA_TOKENS" ] && echo "$TOKENS_RESPONSE" | grep -q '"name"'; then
      echo "   Method 2 - Trying alternative parsing..."
      # Extract token names and assume we need to delete them
      TOKEN_NAMES=$(echo "$TOKENS_RESPONSE" | grep -o '"name":"[^"]*"' | sed 's/"name":"//;s/"//' | tr '\n' ' ')
      echo "   Found token names: $TOKEN_NAMES"
      if [ -n "$TOKEN_NAMES" ]; then
        GITEA_TOKENS="force_delete_all"
      fi
    fi
    
    TOKEN_COUNT=0
    if [ -n "$GITEA_TOKENS" ]; then
      if [ "$GITEA_TOKENS" = "force_delete_all" ]; then
        TOKEN_COUNT=$(echo "$TOKEN_NAMES" | wc -w)
        echo "   Found $TOKEN_COUNT token(s) in Gitea (names: $TOKEN_NAMES)"
        GITEA_TOKEN_LAST8="unknown"
      else
        TOKEN_COUNT=$(echo "$GITEA_TOKENS" | wc -w)
        echo "   Found $TOKEN_COUNT token(s) in Gitea: $GITEA_TOKENS"
        GITEA_TOKEN_LAST8=$(echo "$GITEA_TOKENS" | awk '{print $1}' | tail -c 9)
      fi
    else
      echo "   No tokens found in Gitea"
      GITEA_TOKEN_LAST8=""
    fi
    
    # Decision logic for token management
    if [ "$SECRET_EXISTS" = false ] && [ -z "$GITEA_TOKENS" ]; then
      echo "   Scenario: No secret, no tokens â†’ Create new token"
      CREATE_NEW=true
    elif [ "$SECRET_EXISTS" = true ] && [ -z "$GITEA_TOKENS" ]; then
      echo "   Scenario: Secret exists, no tokens â†’ Delete secret, create new token"
      /usr/local/bin/kubectl delete secret gitea-admin-api-token -n gitea >/dev/null 2>&1
      CREATE_NEW=true
    elif [ "$SECRET_EXISTS" = false ] && [ -n "$GITEA_TOKENS" ]; then
      echo "   Scenario: No secret, tokens exist â†’ Delete all tokens, create new token"
      # Delete all existing tokens
      if [ "$GITEA_TOKENS" = "force_delete_all" ]; then
        # Try to delete by token name (Gitea API might accept names)
        for token_name in $TOKEN_NAMES; do
          if [ -n "$token_name" ]; then
            echo "   Attempting to delete token: $token_name"
            # Try deleting by name first
            if curl -s -X DELETE -u "$ADMIN_USER:$ADMIN_PASS" "http://gitea-http:3000/api/v1/users/$ADMIN_USER/tokens/$token_name" >/dev/null 2>&1; then
              echo "   âœ… Deleted token: $token_name"
            else
              echo "   âŒ Failed to delete token: $token_name"
            fi
          fi
        done
      fi
      CREATE_NEW=true
    else
      # Both exist - compare last 8 digits
      K8S_TOKEN_LAST8=$(echo "$K8S_TOKEN" | tail -c 9)
      if [ "$K8S_TOKEN_LAST8" = "$GITEA_TOKEN_LAST8" ]; then
        echo "   Scenario: Tokens match (last 8: $K8S_TOKEN_LAST8) â†’ Use existing token"
        ADMIN_TOKEN="$K8S_TOKEN"
        CREATE_NEW=false
      else
        echo "   Scenario: Token mismatch (k8s: $K8S_TOKEN_LAST8, gitea: $GITEA_TOKEN_LAST8) â†’ Delete and recreate"
        # Delete existing tokens
        if [ "$GITEA_TOKENS" = "force_delete_all" ]; then
          # Delete by token name
          for token_name in $TOKEN_NAMES; do
            if [ -n "$token_name" ]; then
              echo "   Deleting token by name: $token_name"
              TOKEN_INFO=$(curl -s -u "$ADMIN_USER:$ADMIN_PASS" "http://gitea-http:3000/api/v1/users/$ADMIN_USER/tokens")
              TOKEN_SHA1=$(echo "$TOKEN_INFO" | grep -A5 "\"name\":\"$token_name\"" | head -1 | grep -o '"sha1":"[^"]*"' | sed 's/"sha1":"//;s/"//')
              if [ -n "$TOKEN_SHA1" ]; then
                curl -s -X DELETE -u "$ADMIN_USER:$ADMIN_PASS" "http://gitea-http:3000/api/v1/users/$ADMIN_USER/tokens/$TOKEN_SHA1" >/dev/null
                echo "   Deleted token: ${TOKEN_SHA1: -8}"
              fi
            fi
          done
        else
          # Delete by SHA1
          for token_sha1 in $GITEA_TOKENS; do
            if [ -n "$token_sha1" ]; then
              echo "   Deleting token: ${token_sha1: -8}"
              curl -s -X DELETE -u "$ADMIN_USER:$ADMIN_PASS" "http://gitea-http:3000/api/v1/users/$ADMIN_USER/tokens/$token_sha1" >/dev/null
            fi
          done
        fi
        /usr/local/bin/kubectl delete secret gitea-admin-api-token -n gitea >/dev/null 2>&1
        CREATE_NEW=true
      fi
    fi
    
    # Create new token if needed
    if [ "$CREATE_NEW" = true ]; then
      echo "ðŸ—ï¸ Creating new admin API token..."
      TOKEN_NAME="repo-automation-$(date +%s)"
      RESPONSE=$(curl -s -X POST "http://gitea-http:3000/api/v1/users/$ADMIN_USER/tokens" \
        -H "Content-Type: application/json" \
        -u "$ADMIN_USER:$ADMIN_PASS" \
        -d "{\"name\": \"$TOKEN_NAME\", \"scopes\": [\"all\"]}")
      
      # Extract the full token from response (Gitea API returns full token on creation)
      ADMIN_TOKEN=$(echo "$RESPONSE" | grep -o '"sha1":"[^"]*"' | sed 's/"sha1":"//;s/"//')
      
      if [ -z "$ADMIN_TOKEN" ] || [ ${#ADMIN_TOKEN} -ne 40 ]; then
        echo "âŒ Failed to create new token"
        exit 1
      fi
      
      # Store in k8s secret
      echo "   Storing token in k8s secret..."
      if /usr/local/bin/kubectl create secret generic gitea-admin-api-token \
        --from-literal=token="$ADMIN_TOKEN" \
        -n gitea \
        --dry-run=client -o yaml | /usr/local/bin/kubectl apply -f - >/dev/null 2>&1; then
        echo "   âœ… Token stored successfully in k8s secret"
      else
        echo "   âŒ Failed to store token in k8s secret"
        exit 1
      fi
      
      echo "âœ… Created and stored new token (length: ${#ADMIN_TOKEN})"
    fi
    
    echo "ðŸŽ¯ Using admin token ending with: ${ADMIN_TOKEN: -8}"

    # Check if hello repository already exists
    echo "ðŸ“‹ Checking if hello repository exists..."
    REPO_CHECK=$(curl -s -H "Authorization: token $ADMIN_TOKEN" "http://gitea-http:3000/api/v1/repos/$ADMIN_USER/hello" 2>/dev/null || echo "")

    if echo "$REPO_CHECK" | grep -q '"name":"hello"'; then
      echo "âœ… Repository 'hello' already exists, skipping creation"
    else
      # Create hello repository
      echo "ðŸ—ï¸ Creating hello repository..."
      curl -s -X POST "http://gitea-http:3000/api/v1/user/repos" \
        -H "Authorization: token $ADMIN_TOKEN" \
        -H "Content-Type: application/json" \
        -d '{
          "name": "hello",
          "description": "Hello World CI/CD Demo",
          "private": false,
          "auto_init": true,
          "default_branch": "main"
        }' > /dev/null
      
      # Wait for repository to be created
      sleep 2
      echo "âœ… Repository 'hello' created successfully"
    fi

    # Create temporary directory for repository operations
    TEMP_DIR="/tmp/hello-repo-setup"
    rm -rf "$TEMP_DIR"
    mkdir -p "$TEMP_DIR"
    cd "$TEMP_DIR"

    # Install git if not available
    if ! command -v git >/dev/null 2>&1; then
      echo "ðŸ“¦ Installing git..."
      apk add --no-cache git
    fi

    # Initialize git configuration
    git config --global user.name "$ADMIN_USER"
    git config --global user.email "$ADMIN_USER@xuperson.org"

    # Clone the repository
    echo "ðŸ“¥ Cloning repository..."
    git clone "http://$ADMIN_USER:$ADMIN_PASS@gitea-http:3000/$ADMIN_USER/hello.git" .

    # Check if files already exist (avoid overwriting)
    if [ -f "package.json" ]; then
      echo "âœ… Repository already has content, skipping file creation"
      cd /
      rm -rf "$TEMP_DIR"
      echo "ðŸŽ‰ Hello repository setup completed successfully!"
      exit 0
    fi

    # Create project structure
    echo "ðŸ“ Creating project structure..."
    mkdir -p src/.gitea/workflows

    # Create package.json
    cat > package.json << 'EOF'
    {
      "name": "hello-cicd-demo",
      "version": "1.0.0",
      "description": "Hello World CI/CD Demo with BuildKit",
      "main": "src/index.js",
      "scripts": {
        "start": "node src/index.js",
        "dev": "node src/index.js"
      },
      "keywords": ["hello", "cicd", "buildkit", "gitea"],
      "author": "GitOps Admin",
      "license": "MIT"
    }
    EOF

    # Create Dockerfile
    cat > Dockerfile << 'EOF'
    FROM node:18-alpine

    WORKDIR /app

    COPY package*.json ./
    RUN npm ci --only=production

    COPY src/ ./src/

    EXPOSE 3000

    USER node

    CMD ["npm", "start"]
    EOF

    # Create source code
    cat > src/index.js << 'EOF'
    const http = require('http');
    const port = process.env.PORT || 3000;

    const server = http.createServer((req, res) => {
      res.statusCode = 200;
      res.setHeader('Content-Type', 'text/plain');
      
      const buildInfo = {
        message: 'Hello from Gitea Actions CI/CD! ðŸš€',
        timestamp: new Date().toISOString(),
        build: process.env.BUILD_REF || 'development',
        version: process.env.IMAGE_TAG || '1.0.0'
      };
      
      const response = `${buildInfo.message}

    Build Information:
    - Timestamp: ${buildInfo.timestamp}
    - Build: ${buildInfo.build}
    - Version: ${buildInfo.version}
    - Environment: ${process.env.NODE_ENV || 'development'}

    Powered by Gitea Actions + BuildKit
    `;

      res.end(response);
    });

    server.listen(port, () => {
      console.log(`ðŸš€ Server running on http://localhost:${port}/`);
      console.log(`ðŸ“¦ Build: ${process.env.BUILD_REF || 'development'}`);
      console.log(`ðŸ·ï¸  Version: ${process.env.IMAGE_TAG || '1.0.0'}`);
    });
    EOF

    # Create Gitea Actions workflow
    cat > src/.gitea/workflows/buildkit-ci.yml << 'EOF'
    name: BuildKit CI/CD

    on:
      push:
        branches: [ main, master ]
      pull_request:
        branches: [ main, master ]

    jobs:
      build:
        name: Build and Test
        runs-on: ubuntu-latest
        steps:
        - name: Checkout repository
          run: |
            echo "ðŸ” Cloning repository..."
            git clone ${{ github.server_url }}/${{ github.repository }}.git .
            ls -la
            echo "ðŸ“‹ Repository contents:"
            find . -type f -name "*.js" -o -name "*.json" -o -name "Dockerfile" | head -10

        - name: Test BuildKit connectivity
          run: |
            echo "ðŸ”§ Testing BuildKit connection..."
            echo "BuildKit version:"
            buildctl --version
            echo "ðŸŒ Testing remote BuildKit service..."
            BUILDKIT_HOST=tcp://buildkitd.buildkit.svc.cluster.local:1235 buildctl debug workers

        - name: Set build metadata
          run: |
            echo "ðŸ“ Setting build metadata..."
            export BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
            export BUILD_REF=${{ github.sha }}
            export SHORT_SHA=$(echo $BUILD_REF | cut -c1-7)
            export IMAGE_TAG="v${SHORT_SHA}-$(date +%s)"
            
            echo "BUILD_DATE=$BUILD_DATE" >> $GITHUB_ENV
            echo "BUILD_REF=$BUILD_REF" >> $GITHUB_ENV
            echo "SHORT_SHA=$SHORT_SHA" >> $GITHUB_ENV
            echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV
            
            echo "ðŸ·ï¸  Build metadata:"
            echo "   Date: $BUILD_DATE"
            echo "   Commit: $BUILD_REF"
            echo "   Short SHA: $SHORT_SHA"
            echo "   Image Tag: $IMAGE_TAG"

        - name: Build with BuildKit
          run: |
            echo "ðŸ—ï¸  Building with remote BuildKit..."
            BUILDKIT_HOST=tcp://buildkitd.buildkit.svc.cluster.local:1235 buildctl build \
              --frontend dockerfile.v0 \
              --local context=. \
              --local dockerfile=. \
              --opt build-arg:BUILD_DATE="$BUILD_DATE" \
              --opt build-arg:BUILD_REF="$BUILD_REF" \
              --opt build-arg:IMAGE_TAG="$IMAGE_TAG" \
              --progress=plain

        - name: Build summary
          run: |
            echo "âœ… Build completed successfully!"
            echo "ðŸŽ¯ Summary:"
            echo "   Repository: ${{ github.repository }}"
            echo "   Branch: ${{ github.ref_name }}"
            echo "   Commit: ${{ github.sha }}"
            echo "   Build Tag: $IMAGE_TAG"
            echo ""
            echo "ðŸš€ Ready for deployment automation!"
    EOF

    # Create README
    cat > README.md << 'EOF'
    # Hello CI/CD Demo

    Simple Node.js application demonstrating Gitea Actions with BuildKit.

    ## Features

    - ðŸš€ Gitea Actions CI/CD pipeline
    - ðŸ—ï¸ BuildKit remote building
    - ðŸ“¦ Containerized Node.js application
    - âš¡ Automatic build triggers

    ## Local Development

    ```bash
    npm install
    npm start
    ```

    ## CI/CD Pipeline

    The pipeline automatically:
    1. Tests BuildKit connectivity
    2. Builds Docker image with BuildKit
    3. Sets build metadata and versioning

    ## Architecture

    - **CI**: Gitea Actions
    - **Build**: Remote BuildKit service
    - **Runtime**: Node.js 18 Alpine
    - **Deployment**: GitOps with Flux
    EOF

    # Add all files and commit
    echo "ðŸ“ Committing files..."
    git add .
    git commit -m "feat: initial hello CI/CD demo with Gitea Actions

    - Add Node.js hello world application
    - Configure BuildKit CI/CD pipeline  
    - Include Dockerfile for containerization
    - Setup project structure and documentation

    ðŸ¤– Generated with GitOps automation"

    # Push to repository
    echo "ðŸ“¤ Pushing to repository..."
    git push origin main

    echo "âœ… Hello repository setup completed successfully!"
    echo "ðŸŽ¯ Repository: http://gitea-http:3000/$ADMIN_USER/hello"
    echo "ðŸ”„ Actions will trigger automatically on push"

    # Clean up
    cd /
    rm -rf "$TEMP_DIR"

    echo "ðŸŽ‰ Setup complete! Check Gitea Actions for workflow execution."
---
apiVersion: batch/v1
kind: Job
metadata:
  name: hello-repo-setup
  namespace: gitea
  labels:
    app.kubernetes.io/name: hello-repo-setup
    app.kubernetes.io/component: repository-management
    app.kubernetes.io/managed-by: flux
spec:
  ttlSecondsAfterFinished: 300
  template:
    spec:
      restartPolicy: OnFailure
      serviceAccountName: gitea-runner-init  # Reuse existing service account
      initContainers:
      - name: install-kubectl
        image: bitnami/kubectl:latest
        command:
        - sh
        - -c
        - cp /opt/bitnami/kubectl/bin/kubectl /shared/kubectl && chmod +x /shared/kubectl
        volumeMounts:
        - name: kubectl-binary
          mountPath: /shared
      containers:
      - name: hello-repo-setup
        image: alpine/curl:latest
        command: ["/scripts/hello-repo-setup.sh"]
        volumeMounts:
        - name: script-volume
          mountPath: /scripts
        - name: kubectl-binary
          mountPath: /usr/local/bin/kubectl
          subPath: kubectl
        resources:
          requests:
            memory: "64Mi"
            cpu: "100m"
          limits:
            memory: "128Mi"
            cpu: "200m"
        env:
        - name: GIT_SSL_NO_VERIFY
          value: "1"
      volumes:
      - name: script-volume
        configMap:
          name: hello-repo-setup-script
          defaultMode: 0755
      - name: kubectl-binary
        emptyDir: {}