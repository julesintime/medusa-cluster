---
apiVersion: v1
kind: ConfigMap
metadata:
  name: admin-token-script
  namespace: gitea
  labels:
    app.kubernetes.io/name: gitea-admin-token
    app.kubernetes.io/component: token-management
    app.kubernetes.io/managed-by: flux
data:
  admin-token.sh: |
    #!/bin/sh
    set -e

    echo "üîÑ Creating Gitea admin API token..."

    # Get admin credentials from Kubernetes secrets
    ADMIN_USER=$(kubectl get secret gitea-admin-secrets -n gitea -o jsonpath='{.data.username}' | base64 -d)
    ADMIN_PASS=$(kubectl get secret gitea-admin-secrets -n gitea -o jsonpath='{.data.password}' | base64 -d)

    echo "üì° Testing Gitea API connection..."
    if ! curl -s -f -u "$ADMIN_USER:$ADMIN_PASS" "http://gitea-http:3000/api/v1/version" >/dev/null; then
      echo "‚ùå Cannot connect to Gitea API"
      exit 1
    fi
    echo "‚úÖ Gitea API is accessible"

    # Check for existing admin API token
    if kubectl get secret gitea-admin-api-token -n gitea >/dev/null 2>&1; then
      EXISTING_TOKEN=$(kubectl get secret gitea-admin-api-token -n gitea -o jsonpath='{.data.token}' | base64 -d)
      if [ ! -z "$EXISTING_TOKEN" ] && [ ${#EXISTING_TOKEN} -eq 40 ]; then
        if curl -s -f -H "Authorization: token $EXISTING_TOKEN" "http://gitea-http:3000/api/v1/user" >/dev/null; then
          echo "‚úÖ Valid admin token already exists (length: ${#EXISTING_TOKEN})"
          exit 0
        fi
      fi
      echo "‚ö†Ô∏è  Existing token is invalid, will create new one"
    fi

    # Clean up existing tokens in Gitea
    echo "üßπ Cleaning up existing API tokens..."
    TOKENS_RESPONSE=$(curl -s -u "$ADMIN_USER:$ADMIN_PASS" "http://gitea-http:3000/api/v1/users/$ADMIN_USER/tokens")
    TOKEN_IDS=$(echo "$TOKENS_RESPONSE" | grep -o '"id":[0-9]*' | sed 's/"id"://' || echo "")

    if [ ! -z "$TOKEN_IDS" ]; then
      echo "   Deleting existing tokens..."
      for token_id in $TOKEN_IDS; do
        curl -s -X DELETE "http://gitea-http:3000/api/v1/users/$ADMIN_USER/tokens/$token_id" \
          -u "$ADMIN_USER:$ADMIN_PASS" >/dev/null
      done
    fi

    # Create new admin token
    echo "üèóÔ∏è Creating new admin API token..."
    RESPONSE=$(curl -s -X POST "http://gitea-http:3000/api/v1/users/$ADMIN_USER/tokens" \
      -H "Content-Type: application/json" \
      -u "$ADMIN_USER:$ADMIN_PASS" \
      -d '{
        "name": "flux-automation", 
        "scopes": ["all"]
      }')

    # Extract token
    ADMIN_TOKEN=$(echo "$RESPONSE" | grep -o '"sha1":"[a-f0-9]*"' | sed 's/"sha1":"//;s/"//')

    if [ -z "$ADMIN_TOKEN" ] || [ ${#ADMIN_TOKEN} -ne 40 ]; then
      echo "‚ùå Failed to create admin token"
      echo "Response: $RESPONSE"
      exit 1
    fi

    echo "‚úÖ Admin token created (length: ${#ADMIN_TOKEN})"

    # Test the token
    if ! curl -s -f -H "Authorization: token $ADMIN_TOKEN" "http://gitea-http:3000/api/v1/user" >/dev/null; then
      echo "‚ùå New token failed validation"
      exit 1
    fi
    echo "‚úÖ Token validation successful"

    # Store in Kubernetes secret
    kubectl create secret generic gitea-admin-api-token \
      --from-literal=token="$ADMIN_TOKEN" \
      --namespace=gitea \
      --dry-run=client -o yaml | kubectl apply -f -

    echo "üíæ Admin token stored in secret 'gitea-admin-api-token'"
---
apiVersion: batch/v1
kind: CronJob
metadata:
  name: gitea-admin-token-sync
  namespace: gitea
  labels:
    app.kubernetes.io/name: gitea-admin-token-sync
    app.kubernetes.io/component: token-management
    app.kubernetes.io/managed-by: flux
spec:
  schedule: "*/10 * * * *"  # Run every 10 minutes
  successfulJobsHistoryLimit: 1
  failedJobsHistoryLimit: 1
  jobTemplate:
    spec:
      ttlSecondsAfterFinished: 300
      template:
        spec:
          restartPolicy: OnFailure
          serviceAccountName: gitea-runner-init
          containers:
          - name: admin-token-sync
            image: alpine/curl:latest
            command: ["/scripts/admin-token.sh"]
            volumeMounts:
            - name: script-volume
              mountPath: /scripts
            - name: kubectl-binary
              mountPath: /usr/local/bin/kubectl
              subPath: kubectl
            resources:
              requests:
                memory: "32Mi"
                cpu: "50m"
              limits:
                memory: "64Mi"
                cpu: "100m"
          initContainers:
          - name: install-kubectl
            image: bitnami/kubectl:latest
            command:
            - sh
            - -c
            - cp /opt/bitnami/kubectl/bin/kubectl /shared/kubectl && chmod +x /shared/kubectl
            volumeMounts:
            - name: kubectl-binary
              mountPath: /shared
          volumes:
          - name: script-volume
            configMap:
              name: admin-token-script
              defaultMode: 0755
          - name: kubectl-binary
            emptyDir: {}